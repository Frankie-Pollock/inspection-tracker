<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Property</title>
  <link rel="stylesheet" href="./css/styles.css">
</head>

<body>
<header class="topbar">
  <div class="topbar__brand">Inspection Tracker</div>
  <nav class="topbar__nav">
    <a href="./index.html">Home</a>
    <a href="./properties.html">Properties</a>
    <a href="./create.html">Create</a>
  </nav>
</header>

<main class="container">
  <div class="card card--header">
    <h1 id="title">Property</h1>
    <p class="small" id="meta"></p>
  </div>

  <!-- 3-column top row; Tasks full width below -->
  <section class="grid grid-3">

    <!-- Power / BGAS (MASTER HEIGHT) -->
    <div class="card" id="card_power">
      <h2>Power / BGAS</h2>

      <label for="p_status">Status</label>
      <select id="p_status"></select>

      <label for="p_meter">Meter type (optional)</label>
      <select id="p_meter">
        <option value="">—</option>
        <option value="credit">Credit</option>
        <option value="payg">PAYG</option>
        <option value="rti_keymeter">RTI KEYMETER</option>
        <option value="e10">E10</option>
      </select>

      <div class="chk">
        <input type="checkbox" id="p_taken" />
        <label for="p_taken" class="chk__label">Supply taken over (E10)</label>
      </div>

      <label for="p_notes">Notes</label>
      <textarea id="p_notes" rows="3" placeholder="e.g. Awaiting meter type from BGAS (date)"></textarea>

      <div class="row row--gap">
        <button class="btn" id="p_save" type="button">Save Power Status</button>
        <span class="small" id="p_msg"></span>
      </div>
    </div>

    <!-- Checklist (MATCH POWER HEIGHT + SCROLL INSIDE) -->
    <div class="card card--scroll" id="card_checklist">
      <h2>Checklist</h2>
      <div id="req" class="stack scrollbody"></div>
    </div>

    <!-- Next Actions (MATCH POWER HEIGHT + SCROLL INSIDE) -->
    <div class="card card--scroll" id="card_actions">
      <h2>Next Actions</h2>
      <div class="scrollbody">
        <ul id="actions" class="actions"></ul>
      </div>
    </div>

    <!-- Tasks (FULL WIDTH) -->
    <div class="card span-all" id="card_tasks">
      <div class="card__head">
        <h2 style="margin:0;">Tasks</h2>
        <span class="small" id="t_msg"></span>
      </div>

      <div class="tablewrap">
        <table class="table" id="tasks_table">
          <thead>
            <tr>
              <th>Task</th>
              <th>Status</th>
              <th>Requires Power</th>
              <th>Completed</th>
              <th></th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

  </section>

  <script type="module">
    import { supabase } from "./js/supabaseClient.js";
    import { requireAuth } from "./js/authGate.js";
    import { POWER_STATES, buildTaskSeed, applyRules, nextActions } from "./js/workflow.js";

    await requireAuth();

    const id = new URLSearchParams(location.search).get("id");

    const title = document.querySelector("#title");
    const meta  = document.querySelector("#meta");

    const reqDiv = document.querySelector("#req");
    const actionsList = document.querySelector("#actions");

    const pStatusSel = document.querySelector("#p_status");
    const pMeterSel  = document.querySelector("#p_meter");
    const pTakenChk  = document.querySelector("#p_taken");
    const pNotesArea = document.querySelector("#p_notes");
    const pSaveBtn   = document.querySelector("#p_save");
    const pMsg       = document.querySelector("#p_msg");

    const tMsg       = document.querySelector("#t_msg");
    const tasksTbody = document.querySelector("#tasks_table tbody");

    // ------- HEIGHT SYNC (Power is master height) -------
    function syncTopHeights() {
      const power = document.querySelector("#card_power");
      const checklist = document.querySelector("#card_checklist");
      const actions = document.querySelector("#card_actions");
      if (!power || !checklist || !actions) return;

      // Clear first so measurement is correct
      checklist.style.height = "";
      actions.style.height = "";

      const h = Math.ceil(power.getBoundingClientRect().height);

      checklist.style.height = h + "px";
      actions.style.height = h + "px";
    }

    // Observe power card resizing (e.g. fonts, dropdown changes, notes text wrapping)
    const ro = new ResizeObserver(() => syncTopHeights());
    ro.observe(document.querySelector("#card_power"));
    window.addEventListener("resize", syncTopHeights);

    // Fill power status dropdown
    pStatusSel.innerHTML = "";
    Object.entries(POWER_STATES).forEach(([k, label]) => {
      const opt = document.createElement("option");
      opt.value = k;
      opt.textContent = label;
      pStatusSel.appendChild(opt);
    });

    function prettyLabel(key){
      return key
        .replaceAll("_"," ")
        .replace(/\b\w/g, c => c.toUpperCase());
    }

    function renderChecklistFlags(propertyRow) {
      reqDiv.innerHTML = "";

      const items = Object.entries(propertyRow)
        .filter(([k,v]) => typeof v === "boolean")
        .map(([k,v]) => ({ key: k, value: v, label: prettyLabel(k) }));

      items.sort((a,b) => {
        if (a.value === b.value) return a.label.localeCompare(b.label);
        return a.value ? -1 : 1;
      });

      const needed = items.filter(x => x.value);
      const notNeeded = items.filter(x => !x.value);

      if (needed.length) {
        const h = document.createElement("div");
        h.className = "sectionTitle";
        h.textContent = "Needed";
        reqDiv.appendChild(h);

        needed.forEach(x => {
          const row = document.createElement("div");
          row.className = "pillrow";
          row.innerHTML = `
            <span class="badge ok">Y</span>
            <span class="pillrow__text">${x.label}</span>
          `;
          reqDiv.appendChild(row);
        });
      }

      const h2 = document.createElement("div");
      h2.className = "sectionTitle";
      h2.textContent = "Not needed";
      reqDiv.appendChild(h2);

      notNeeded.forEach(x => {
        const row = document.createElement("div");
        row.className = "pillrow pillrow--dim";
        row.innerHTML = `
          <span class="badge">—</span>
          <span class="pillrow__text">${x.label}</span>
        `;
        reqDiv.appendChild(row);
      });

      // After checklist renders, re-sync heights (scroll area height changes)
      syncTopHeights();
    }

    function renderNextActions(tasks, powerStatus) {
      const list = nextActions(tasks, powerStatus);
      actionsList.innerHTML = "";
      list.forEach(line => {
        const li = document.createElement("li");
        li.textContent = line;
        actionsList.appendChild(li);
      });

      syncTopHeights();
    }

    async function ensurePowerRow(propertyRow) {
      const { data } = await supabase
        .from("power_status")
        .select("*")
        .eq("property_id", propertyRow.id)
        .maybeSingle();

      if (data) return data;

      const { data: created, error } = await supabase
        .from("power_status")
        .insert({ property_id: propertyRow.id, status: propertyRow.power_status })
        .select("*")
        .single();

      if (error) throw error;
      return created;
    }

    async function ensureTasks(propertyRow) {
      const { data: tasks, error } = await supabase
        .from("tasks")
        .select("*")
        .eq("property_id", propertyRow.id)
        .order("created_at", { ascending: true });

      if (error) throw error;
      if (tasks && tasks.length) return tasks;

      const seeds = buildTaskSeed(propertyRow).map(t => ({
        property_id: propertyRow.id,
        key: t.key,
        name: t.name,
        requires_power: t.requires_power
      }));

      if (seeds.length) {
        const { error: insErr } = await supabase.from("tasks").insert(seeds);
        if (insErr) throw insErr;
      }

      const { data: tasks2, error: err2 } = await supabase
        .from("tasks")
        .select("*")
        .eq("property_id", propertyRow.id)
        .order("created_at", { ascending: true });

      if (err2) throw err2;
      return tasks2 || [];
    }

    function statusBadgeHtml(status) {
      if (status === "complete") return `<span class="badge ok">complete</span>`;
      if (status === "blocked") return `<span class="badge blocked">blocked</span>`;
      if (status === "in_progress") return `<span class="badge warn">in progress</span>`;
      return `<span class="badge">${status}</span>`;
    }

    async function renderTasks(tasks) {
      tasksTbody.innerHTML = "";

      tasks.forEach(t => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>
            <div class="taskname">${t.name}</div>
            ${t.blocked_reason ? `<div class="small muted">${t.blocked_reason}</div>` : ""}
          </td>
          <td>${statusBadgeHtml(t.status)}</td>
          <td>${t.requires_power ? "Yes" : "No"}</td>
          <td>${t.completed_at ? new Date(t.completed_at).toLocaleString() : ""}</td>
          <td class="td-actions">
            <button class="btn btn--tiny" data-action="toggle" data-id="${t.id}">
              ${t.status === "complete" ? "Mark not complete" : "Mark complete"}
            </button>
          </td>
        `;
        tasksTbody.appendChild(tr);
      });

      tasksTbody.querySelectorAll('button[data-action="toggle"]').forEach(btn => {
        btn.addEventListener("click", async () => {
          const taskId = btn.getAttribute("data-id");
          const task = tasks.find(x => x.id === taskId);
          if (!task) return;

          const makeComplete = task.status !== "complete";

          const { error } = await supabase
            .from("tasks")
            .update({
              status: makeComplete ? "complete" : "not_started",
              completed_at: makeComplete ? new Date().toISOString() : null,
              blocked_reason: null
            })
            .eq("id", taskId);

          if (error) alert(error.message);
          await loadAll();
        });
      });
    }

    async function loadAll() {
      tMsg.textContent = "";
      pMsg.textContent = "";

      const { data: prop, error: propErr } = await supabase
        .from("properties")
        .select("*")
        .eq("id", id)
        .single();

      if (propErr) {
        title.textContent = "Not found";
        meta.textContent = propErr.message;
        throw propErr;
      }

      title.textContent = prop.address;
      meta.textContent = `Power: ${prop.power_status} • Created: ${new Date(prop.created_at).toLocaleString()}`;

      renderChecklistFlags(prop);

      const power = await ensurePowerRow(prop);
      pStatusSel.value = power.status || "not_checked";
      pMeterSel.value  = power.meter_type || "";
      pTakenChk.checked = !!power.supply_taken_over;
      pNotesArea.value = power.notes || "";

      // after power fields update, sync heights again
      syncTopHeights();

      let tasks = await ensureTasks(prop);
      tasks = applyRules(tasks, power.status);

      for (const t of tasks) {
        if (t.status === "complete") continue;
        await supabase.from("tasks")
          .update({ status: t.status, blocked_reason: t.blocked_reason })
          .eq("id", t.id);
      }

      const { data: tasksFinal, error: tasksErr } = await supabase
        .from("tasks")
        .select("*")
        .eq("property_id", prop.id)
        .order("created_at", { ascending: true });

      if (tasksErr) { tMsg.textContent = tasksErr.message; throw tasksErr; }

      await renderTasks(tasksFinal || []);
      renderNextActions(tasksFinal || [], power.status);

      // final sync after everything renders
      syncTopHeights();
    }

    pSaveBtn.addEventListener("click", async () => {
      pMsg.textContent = "";

      const status = pStatusSel.value;
      const meter_type = pMeterSel.value || null;
      const supply_taken_over = pTakenChk.checked;
      const notes = pNotesArea.value.trim() || null;

      const { error: pErr } = await supabase
        .from("power_status")
        .update({ status, meter_type, supply_taken_over, notes })
        .eq("property_id", id);

      if (pErr) { pMsg.textContent = pErr.message; return; }

      const { error: propErr } = await supabase
        .from("properties")
        .update({ power_status: status })
        .eq("id", id);

      if (propErr) { pMsg.textContent = propErr.message; return; }

      pMsg.textContent = "Saved.";
      await loadAll();
    });

    await loadAll();
  </script>
</main>
</body>
</html>
